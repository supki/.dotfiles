:set prompt ">>> "
:set prompt2 ""
:set editor vim

import           Control.Applicative
import           Control.Monad
import           Data.Bits
import           Data.Char
import           Data.Data
import           Data.Fixed
import           Data.Function (fix, on)
import           Data.Foldable (Foldable)
import           Data.Traversable (Traversable)
import           Data.Int
import           Data.List
import           Data.Maybe
import           Data.Ratio
import           Data.String
import           Data.Tuple
import           Data.Typeable
import           Data.Word
import           Debug.Trace
import           GHC.Generics
import           Numeric
import           System.IO
import           System.IO.Unsafe
import           Text.Printf
import           Unsafe.Coerce

import           Control.Concurrent.STM.TVar
import           Control.Concurrent.STM.TChan
import           Control.Concurrent.STM.TQueue
import           Control.Lens
import           Control.Comonad
import           Control.Monad.Reader
import           Control.Monad.Writer hiding ((<>))
import           Control.Monad.State
import           Control.Monad.Free
import           Control.Monad.STM
import           Control.Monad.Trans
import           Control.Monad.Trans.Either
import           Control.Monad.Trans.Maybe
import           Data.Bifunctor
import           Data.Bits.Lens
import           Data.Data.Lens
import           Data.Functor.Identity
import           Data.List.Lens
import           Data.Proxy
import           Data.Reflection
import           Data.Semigroup
import           Data.Tagged
import           Data.Void
import           Numeric.Lens
import           Prelude.Unicode
import           System.Directory
import           System.Environment
import           System.Exit
import           System.FilePath
import           System.FilePath.Lens
import           System.Posix
import           Text.Parsec hiding ((<|>), many)

import qualified Control.Exception          as E
import qualified Data.Map.Strict            as M
import qualified Data.IntMap.Strict         as IM
import qualified Data.HashMap.Strict        as HM
import qualified Data.Foldable              as F
import qualified Data.Traversable           as F
import qualified Data.Set                   as S
import qualified Data.IntSet                as IS
import qualified Data.HashSet               as HS
import qualified Data.List.NonEmpty         as N
import qualified Data.Sequence              as Q
import qualified Data.ByteString            as B
import qualified Data.ByteString.Char8      as BC
import qualified Data.ByteString.Lazy       as BL
import qualified Data.ByteString.Lazy.Char8 as BLC
import qualified Data.Text                  as T
import qualified Data.Text.IO               as T
import qualified Data.Text.Encoding         as T
import qualified Data.Text.Lazy             as TL
import qualified Data.Text.Lazy.Encoding    as TL
import qualified Data.Text.Lazy.IO          as TL

import           System.Command.QQ
import           System.Wordexp.Simple

:set -fwarn-alternative-layout-rule-transitional
:set -fwarn-auto-orphans
:set -fwarn-deprecated-flags
:set -fwarn-deprecations
:set -fwarn-dodgy-exports
:set -fwarn-dodgy-foreign-imports
:set -fwarn-dodgy-imports
:set -fwarn-duplicate-exports
:set -fwarn-hi-shadowing
:set -fwarn-incomplete-patterns
:set -fwarn-incomplete-record-updates
:set -fwarn-lazy-unlifted-bindings
:set -fwarn-missing-fields
:set -fwarn-missing-methods
:set -fwarn-monomorphism-restriction
:set -fwarn-name-shadowing
:set -fwarn-orphans
:set -fwarn-overlapping-patterns
:set -fwarn-tabs
:set -fwarn-unrecognised-pragmas
:set -fwarn-unused-binds
:set -fwarn-unused-imports
:set -fwarn-unused-matches
:set -fwarn-warnings-deprecations
:set -fwarn-wrong-do-bind

:set -fno-warn-type-defaults
:set -fno-warn-unused-do-bind

:set -XBangPatterns
:set -XDataKinds
:set -XDeriveDataTypeable
:set -XDeriveGeneric
:set -XDeriveFoldable
:set -XDeriveFunctor
:set -XDeriveTraversable
:set -XEmptyDataDecls
:set -XExistentialQuantification
:set -XFlexibleContexts
:set -XFlexibleInstances
:set -XFunctionalDependencies
:set -XGADTs
:set -XGeneralizedNewtypeDeriving
:set -XImplicitParams
:set -XKindSignatures
:set -XLambdaCase
:set -XMultiParamTypeClasses
:set -XMultiWayIf
:set -XNoMonomorphismRestriction
:set -XPackageImports
:set -XQuasiQuotes
:set -XRankNTypes
:set -XScopedTypeVariables
:set -XStandaloneDeriving
:set -XTupleSections
:set -XTypeFamilies
:set -XTypeOperators
:set -XUndecidableInstances
:set -XUnicodeSyntax
:set -XViewPatterns

:{
let asAppliedTo :: (a -> b) -> a -> (a -> b)
    asAppliedTo = const
:}

deriving instance Show a => Show (Identity a)
deriving instance Eq a => Eq (Identity a)
deriving instance Ord a => Ord (Identity a)

deriving instance Show a => Show (Const a b)
deriving instance Eq a => Eq (Const a b)
deriving instance Ord a => Ord (Const a b)

:set +t
